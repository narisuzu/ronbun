\subsection{运行时服务}
运行时是供实例执行的运行时（runtime）环境，一个运行时中可以执行多个实例，所有的实例会被管理在一个
HashMap 中。实例在初始化时被插入该HashMap，在结束时移除。

\subsubsection{实例(Instance)}
实例是运行时中运行的基本单位，运行时服务的含义就是运行实例的服务。
一个实例由某个车站所实例化而来，在运行时中和表现层可以直接与相应的实例进行交互。
若拿做菜作类比，车站是“菜谱”、实例是“菜肴”、“上菜”是实例初始化并运行，与实例交互就是“吃菜”
一台实例的生命周期如下图所示：

一台实例只有一个逻辑用户，这是显而易见的，现实中一台终端只能同时由一个人操作。但本案还支持管理员控制
和状态共享。管理员控制是允许管理员对任意一个运行中的实例进行最高权限的操作，包括普通用户的所有权限还有
设置隐患（故障），任意生成列车等不和现实逻辑但有益于提高教学效率的操作。

\subsubsection{状态对象}
状态对象是状态机的组件，由 Signal（信号机状态对象），Node（结点状态对象） 和 Train（车辆状态对象）组成，
状态对象中保存着相应车站信号设备的实时状态。

\paragraph{}信号状态

譬如，Signal 中的二元组 filament\_status 表征灯丝状态，灯丝状态可取表\ref{fila_state}。
Signal 中的 state 属性表征信号机点灯状态，其可如表\ref{sgn_state}所列。
\begin{table}[htpb!]
    \centering
    \caption{\label{fila_state}灯丝状态定义}
    \begin{threeparttable}
        \begin{tabular}{cc}
            \toprule
            属性   & 含义 \\
            \midrule
            Normal & 正常 \\
            Fused  & 熔断 \\
            None   & 空   \\
            \bottomrule
        \end{tabular}
    \end{threeparttable}
\end{table}
\begin{table}[htpb!]
    \centering
    \caption{\label{sgn_state}信号机状态定义}
    \begin{threeparttable}
        \begin{tabular}{cc}
            \toprule
            属性 & 含义 \\
            \midrule
            L    & 绿   \\
            U    & 黄   \\
            H    & 红   \\
            B    & 月白 \\
            A    & 蓝   \\
            UU   & 双黄 \\
            LU   & 绿黄 \\
            LL   & 双绿 \\
            US   & 黄闪 \\
            HB   & 红白 \\
            OFF  & 灭灯 \\
            \bottomrule
        \end{tabular}
    \end{threeparttable}
\end{table}

\paragraph{}结点状态

与信号的状态类似，结点状态枚举参见表 \ref{node_state}，
但需要注意的是在程序中还定义了锁闭枚举（Lock），但Lock并不参与业务逻辑，
真正表征锁闭状态的是 Node 状态对象中的is\_lock 属性。
该Lock枚举仅仅用于当Node锁闭时序列化成为状态帧向表示层发送。
\begin{table}[htpb!]
    \centering
    \caption{\label{node_state}轨道区段状态定义}
    \begin{threeparttable}
        \begin{tabular}{lcl}
            \toprule
            属性       & 含义 & 轨道电路状态     \\
            \midrule
            Vacant     & 空闲 & 调整             \\
            Occupied   & 占用 & 分路             \\
            Unexpected & 异常 & 断轨、分路不良等 \\
            \bottomrule
        \end{tabular}
    \end{threeparttable}
\end{table}

结点状态可以由用户输入和车辆运动两种事件决定，相较信号状态更复杂一些，
因此用状态转移图来表示，如图 \ref{node_fsm}（不考虑非理想状况，如司机冒进信号）：

\begin{figure}[htpb!]
    \centering
    \input{figures/node_fsm.tex}
    \caption{\label{node_fsm}结点状态转移图}
\end{figure}

其中状态变量\{a, b, c\}分别为：a: 0为vacant、1为occupied、2为unexpected， b: 是否锁闭 c: 是否曾占用
。图中未绘出异常状态，但，图\ref{node_fsm} 中的任意一种状态均可发生异常从而使node状态变为 unexpected.

\paragraph{}车辆对象

Train 中除了有id属性外，还有以下两个属性：

past\_node：其记录着一列车辆所历经的结点。用于解锁区段结点以及判断考题得分。
车辆对象可以自动的行进，如同一个完美的司机。

process：不大于1的浮点数，表示车辆在当前结点的进程，
比如 0.5 表示车辆位于当前节点正中


\subsubsection{实例组成}
一个实例基本由 fsm、topo、layout 三个独立的部分构成。
在实例初始化时会通过Station信息同时生成这三个部分。

\paragraph{}topo

topo 保存一个实例所有的拓扑关系，包括车站图（即联锁关系，包含R关系和S关系），并置信号机映射，差置信号机映射，以及独立按钮映射，
topo 能表征一个实例的各种组件（信号机、节点和按钮）在联锁逻辑上是如何耦合的。比如R关系表示了轨道结点之间
是怎么连接的。

通过topo，运行时可以静态地从车站的拓扑关系上找到一条可能的进路。再通过后续的判断，来确定这条可能的进路是不是
进路。

\paragraph{}状态机（FSM）

FSM（finite-state machine）即有限状态机, 保存了一个实例所有的状态对象，包括上述的信号机、节点和车辆，并且管理
整个车站的状态。后文将能改变FSM状态的因子称为事件(Event)，而每发生一个事件，都有可能会导致
实例向表现层发送一个状态帧。

\paragraph{}布局（Layout）

实例中的布局对象是车站布局的载荷，即在用户请求车站布局时向表示层发送的车站布局信息。
布局在实例初始化时会和状态机同时生成，实际上，关于表现层的车站布局信息有两种方案，其一是不在初始化实例时在实例中储存布局信息
而在用户请求车站布局时再计算得出。其二是本案采用的，在实例初始化时同步计算布局信息并保存，当用户请求时直接返回布局信息。
这样做的好处是，以空间换时间，若有大量用户同时访问一个实例，或一个用户多次访问一个实例（如刷新页面），表现层请求车站布局用来渲染
车站平面图时，多次计算布局信息会造成不必要的时间开销。
一个布局由一组结点布局对象（NodeData）、一组信号布局对象（SignalData）和一个标题构成，标题用于渲染车站名。
NodeData和SignalData 用于渲染结点和信号机。

\begin{table}[htpb!]
    \centering
    \caption{\label{node_data}结点布局对象结构}
    \begin{threeparttable}
        \begin{tabular}{lc}
            \toprule
            属性       & 作用         \\
            \midrule
            NodeID     & 唯一确定Node \\
            TrackID    & 所属轨道电路 \\
            LeftP      & 左端点       \\
            RightP     & 右端点       \\
            LeftJoint  & 左端绝缘节   \\
            RightJoint & 右端绝缘节   \\
            \bottomrule
        \end{tabular}
    \end{threeparttable}
\end{table}

\begin{table}[htpb!]
    \centering
    \caption{\label{sgn_data}信号布局对象结构}
    \begin{threeparttable}
        \begin{tabular}{lc}
            \toprule
            属性          & 作用           \\
            \midrule
            id            & 唯一确定Signal \\
            SgnKind       & 信号类型       \\
            SgnMount      & 安装方式       \\
            Pos           & 安装位置       \\
            dir           & 左右朝向       \\
            side          & 上下两侧       \\
            ProtectNodeID & 防护Node       \\
            Btns          & 信号机按钮     \\
            \bottomrule
        \end{tabular}
    \end{threeparttable}
\end{table}

\paragraph{}考试管理器（ExamManager）

考试管理器是可选属性(Option)，若且唯若实例为考试实例时才会有此属性，管理考试题目、考试进度以及考试分数
相关的内容。一场考试包含数个题目，考试管理器在考题被完成、跳过、超时的时候，会向表现层发送状态帧，供GUI
显示相关的考试进度，对于每一道考题在数据库中是由题目外键和实例外键构成的联合主键，意即即使对于参加
同一场考试的不同用户，其题目是相同的，对于一道相同的题目，可能有会出现在很多名用户的考试管理器中。
通过实例id和题目id，可以唯一的确定一个实例中的一道考题。考试管理器也可以凭此将用户的成绩信息上传
至数据库中。详细的数据结构可以参见第六章。

\subsubsection{获取实例信息}
表现层(用户)能从实例上\emph{取得}的信息，有布局信息、考题信息和状态信息三种，布局信息和考题信息是静态的、
一次性的。而状态信息是实时的，动态的。布局信息用来正确地绘制车站的布局，考题信息用于向用户下达考试实例的题目，
状态信息用来更新车站上信号设备的状态。布局信息透过布局对象(layout)来传递，考试信息通过考试管理器发送，
状态信息透过状态帧(GameFrame)来传递。

uroj的运行时，无论在哪一层，布局和状态都是无耦合的。这意味着表现层需要单独地查询车站的布局和订阅实例状态
的更新。

\paragraph{}查询车站布局(Query Station Layout)

下面将介绍运行时是如何将上述的布局信息呈递给表现层的，而我们将在第九章看到如何利用表 \ref{node_data}
和表 \ref{sgn_data} 中所列之属性在网页上正确地渲染出车站平面。

运行时提供的车站布局接口是 station\_layout 方法，该方法会返回一个请求车站的layout的副本。当请求该
方法时，需要一个传入一个字符串作为id(UUID)参数，用来指明所请求的layout是哪个实例的layout，
运行时会在当前运行的实例中寻找用户所输入的id所对应的实例，
如果没找到则说明输入的id不是某个正在运行的实例。
如果找到了则把该实例的layout克隆并返回。

\paragraph{}查询考题信息(Query Instance Question)

若且唯若实例为考试实例时（即实例的考试管理器不为空），表现层会查询实例的考题信息，考题信息

\paragraph{}订阅状态更新(Subscribe Status Update)

为保证表现层的状态能实时的被更新渲染，状态更新应该是长连接的单向流，uroj采用了graphql 的 subscription。
其能通过websocket 协议源源不断的向订阅者(表现层)发送数据。

状态帧(GameFrame)即是状态更新的载荷(Payload)，即在需要更新表现层车站状态渲染的时候向
表现层发送的“新状态”，譬如某个信号机的灯光颜色，某个车辆的新位置，考试题目的完成，等等。
但不是所有的事件都会导致产生并发送状态帧，譬如轨道曾占用是用于解锁逻辑判断使用的，而不需要在视图上有任何表示，
所以轨道曾占用就不会产生状态帧。

状态帧目前分为6种，UpdateSignal：更新信号，UpdateNode：更新结点，UpdateGlobalStatus：更新全局状态
MoveTrain：车辆移动，UpdateQuestion：更新题目，InstanceFinish：实例结束。
其中UpdateSignal和UpdateNode分别包含id和state两个属性，
表示更新设备的id和新状态。UpdateGlobalStatus则是UpdateSiganal和UpdateNode的数组。
而MoveTrain有id属性表示被移动车辆的id，node\_id属性表示车辆所处的结点编号，process属性，表示车辆在当前节点的位置
，为小于1的浮点数，指的是车辆相对于结点的进程（即车辆走过了node\_id 结点的百分之几）。这些属性是与Train状态对象的
属性相同的，另外为了正确的渲染车辆的位置，MoveTrain状态帧还有一个属性名为 dir，意思是方向。结合process就能知道
此时车辆是在结点从左到右百分之几还是从右到左百分之几的位置处。
UpdateQuestion 只有当实例为考试实例时才会被发送，可以将某个编号的考题更新至：已完成、已超时、已跳过三个状态。
另外，和前四种状态帧不同的是，前四种状态帧是由状态机发送的，而更新考题状态帧是由考试管理器发送的。

状态更新的接口是 game\_update 方法，该方法会返回一个内容为GameFrame(状态帧)的流。另外需要考虑的是
当表现层订阅状态更新后，其会不断的获得实例的最新状态变化。但也仅限于状态变化，因为如果没有一些途径让
表现层得知订阅状态更新时的初始状态，就不能正确地表现整个车站的所有状态。因此在订阅状态更新时收到的首个
状态帧一定是UpdateGlobalStatus，用来渲染请求状态更新时车站的状态，后续的状态帧都是在这个初始状态之上的
状态改变。这便是UpdateGlobalStatus状态帧存在的意义，
另外，当有需求重置整个实例时，UpdateGlobalStatus这个状态帧也会被发送。

可能会发现，前文所定义的状态帧中的状态都只包含了新状态，而没有包含旧状态。这和某些事件驱动应用中的“事件”
不同。在本案中，表现层对于状态更新的策略是乐观的。意即表现层总是认为：自己接收到的状态帧中包含着最新的
状态。因此状态帧中不需要加入旧状态或者时间戳以保证状态变化的连续。

\subsubsection{实例初始化与运行}
无论用户是想要进行前文提到的请求车站布局(layout)亦或者是更新车站状态，最大的一个前提是实例要处于运行状态。
这是理所当然的，就像你不能品尝到一碟没有上菜的菜肴一样。你需要先让实例加载并运行在运行时内，才能获取
实例的车站布局或者更新实例状态。

在第五章，我们能够在api层中定义一个实例，预约实例运行的时间、配置实例相关的信息，并将这些信息存在数据库的
Instance 表中，那么在实例所指定的运行时 上，就可以运行该实例。要想运行实例。用户
需要输入实例ID（UUID）。而后运行时会通过数据访问层(uroj-db)在Instance表中查找相应的实例。
如果未找到，则说明访问的实例ID不合法。如果寻到对应的实例，则会验证实例的相关信息：如果访问实例
的用户没有权限（没有Guest、Player或Operator 权限），则返回forbidden禁止访问。若用户有权限。那么
还需要验证开始时间。因为在表现层，未满足开始时间要求的实例根本不会渲染开始入口（相关按钮），这里的
验证看似冗余而没有必要，但其实不然，uroj的各个模块间的耦合策略是悲观的，意思是，运行时 不应该信任
前端（表现层）传来的数据一定不会包含违反开始时间约束的实例访问请求。

当一切验证完成，运行时 便会将 yaml 反序列化成 RawStation 对象，用数据库中查到的实例信息，和RawStation
对象在运行时中新建实例。在这个过程中，Instance 的new方法会将传入的RawStation 转化为 fsm, topo 和 layout。

下面说明其中某些属性的推导过程，首先给出一个定义和一个推论：
\begin{definition}
    对于一个信号机，我们称其朝向的结点为该信号机的朝向结点，称其背向的结点为该信号机的防护结点
\end{definition}
\begin{corollary}
    某个信号机的朝向等于其所防护区段的端，相反于列车行进方向和其防护区段相对信号机的位置。
\end{corollary}
举例说明：

\begin{figure}[htbp!]
    \centering
    \input{figures/exm_node_sgn.tex}
    \caption{\label{ens1}例子}
\end{figure}

上述信号机朝\uline{左}，因此其左边的结点为该信号机的朝向结点，右边的结点为其防护结点，并且，
该信号机防护其\uline{右}侧区段的\uline{左}端，限制来自\uline{右}行的调车。有了这个推论
便可以由原始数据推导出下列信息。

\paragraph{}信号机布局对象的位置和朝向

应该能注意到表\ref{sgn_prop} 中的 Pos 和 dir 属性是可选的。这是因为其中的pos和dir是缺省值。
即信号机的位置和朝向是可以从其他信息中推断出来的，这两个值如果留空则自动推断，如果不留空则
有限使用pos和dir作为信号机的位置和朝向，那么应该如何推断呢？

一般情况下，信号机位于两个轨道区段的衔接处, 绝缘节的旁边，因此通过表\ref{sgn_prop}定义的ProtectNodeID
和 TowardNodeID 可以找到信号机所对应的防护结点和朝向结点，那么由推论1必然有信号机的朝向
为从防护结点到朝向结点的方向，如果防护结点和朝向结点邻接（即在r关系中存在防护结点到朝向结点的边）
那么在有向图r中就能得知信号机的方向。换言之如果防护结点和朝向结点不邻接，则说明违反了定义1，
说明车站描述文件出错。

对于信号机的位置而言是同理的，由推论1，若信号机朝左则一定位于防护节点的左端点，若其朝右
则一定位于防护结点的右端点。而左端点或右端点的坐标是在RawNode（见表\ref{node_prop} ）
中定义的。

\paragraph{}结点状态对象的防护信号机

对于FSM的结点状态对象来说，需要知道一个Node的左端信号机和右端信号机，
（这里需要明确一点：Fsm的Node状态对象中的左右端信号机，都应指的是防护本结点的信号机。）
可以通过RawStation在信号机上定义的防护结点，结合信号机的朝向就可得知：由推论 1
若信号机朝左，则其防护结点的左端信号机是该信号机，若信号机朝右，则其防护结点的右端信号机
是该信号机。

\subsubsection{结束实例}
相比实例的运行，结束实例要简单得多。结束实例分为两种，自动结束和手动结束。
对于考试实例而言，可以自动结束或手动结束。对于练习
实例则只能手动结束。对于考试实例而言，结束实例时会将考试管理器（ExamManager）的问题成绩
同步至数据库 instance\_questions 表中。对于练习实例没有什么额外的操作。

因为实例保存在HashMap中，因为rust语言的所有权和强制RAII的特性，所以不需要对实例进行析构。
只需要将Instance从HashMap中删除就可以结束实例。

在结束实例之后，会发送一个实例结束状态帧，以在表现层提示用户实例的结束。

\subsubsection{新建进路}
在详细说明建立过程之前，需要强调的一点是，新建进路过程的一个重要的性质为原子性：
和取消进路的分段过程不同，建立进路时必须保证所有轨道节点要么全部锁闭，
要么全部不锁闭（建立失败），不能出现部分节点锁闭部分结点不能锁闭的情况。

若不考虑竞态条件（多线程时），先检测一个可能进路中所有节点是否满足封闭条件，
再决定条件不满足而建立失败或者对所有结点统一进行锁闭以及对其进路扩展集进行征用。

若不事前检测进路锁闭条件，则需要在封闭结点到中途遇到无法锁闭之结点时对之前锁闭的所有结点
进行回滚（Rollback）。事实上，数据库事务的原子性便是通过这种方案保证的。但本案出于建立进路
的性质考量，采用第一种方案。

本案采用了为培训系统改良的新建进路算法，新建进路可以分为几个过程：查找结点、寻径、
进路约束检查、进路条件检查、封闭区段、点灯。

\paragraph{}查找结点

本案排选进路的核心算法以始终结点为输入，但实际上用户的输入却是按钮，如此一来
程序便需要从用户的输入得知用户真正想要建立的进路是从哪一个结点到哪一个结点的。

前文可知本案所定义的按钮有两种，一为信号机按钮，二为独立按钮。独立按钮自然有其到某个结点的映射。
但信号机按钮所映射的实体是信号机，而信号机有两个属性都和结点相关（防护结点和朝向结点）。那么
当用户点击信号机按钮时，究竟哪个结点才是用户想要建立进路的起点，哪个结点才是终点呢？

不难发现，对于起点来说，不论建立哪种进路，起点总是始端信号机的防护结点。
真正有问题的是终点的判断。不同类型的进路其终点和终端信号机的相对位置不同，就算是同种类型的进路，
若终端信号机有并置或差置，位置就又有不同。

枚举所有种类的进路，可以总结出终端结点的规律见表\ref{route_end}。

\paragraph{}寻径

在站场中查找路径本案中采用了petgraph这个crate提供的A*算法，将起点和终点输入，便可能在
有向图R中找到一条路径。但这条路径不一定是我们要找的进路，为了使路径满足进路链的定义。
还需要保证路径中的所有结点都互相没有S关系，即任意两结点在S图中都不存在边。若这一点也满足
，则称这条路径为“可能的进路”。

\paragraph{}进路约束检查

为什么我要将寻径得到的路径成为“可能的路径”呢，这里使用两个例子来说明，第一个例子来分析图\ref{ens2} 情况：

\begin{figure}[ht]
    \centering
    \input{figures/ens2.tex}
    \caption{\label{ens2}例子1}
\end{figure}

若用户点击 D1，D3，则不应该存在合法的进路。若没有额外的约束，则从结点1到结点5确实存在一条完全符合进路链定义
的进路：$1 \rightarrow 3 \rightarrow 5$。但显然这是不应该存在的。

第二个例子：假设想要建立一接车进路，无疑地，用户需要输入的始端信号机是进站信号机，
终端信号机是与始端信号机反向的差置发车信号机。若使用同向的发车信号机作为终端信号机按钮输入，则不应该存在进路。
但一个问题是，一对差置的接车信号机其朝向结点是相同的，而根据要求，接车进路的终点正是终点信号机的朝向结点。因此
若不加限制则会造成若终端按钮点击的是两个差置的接车信号机的任意一个均可以成功找到合法的接车进路。这就是并置和
差置信号机引发的问题。

为解决这些问题，才需要引入方向约束，方向约束是本案中保证进路映射唯一性的一种约束。
进路映射唯一性的含义是：一个进路输入只能找到唯一的进路并且能查到某条进路的输入有且唯有一个。
方向约束的含义是：对于一条可能进路的始/终端方向必须和欲建立进路的列车行进始/终端方向相同，故而
方向约束由两个约束构成：始端方向约束和终端方向约束。

显然地，欲建立进路的列车行进始端方向总是始端信号机的朝向的反向（称为信号机的防护方向），这点很好理解，
司机进入进路时一定是面朝进路的始端防护信号机的，那么车辆的行进方向便是始端信号机朝向的反向。与终点规律相同
欲建立进路列车行进终端方向也需要分类讨论，与终点选择的规律一并总结在表 \ref{route_end} 中。

在查找进路时我们把站场图中寻到的路径成为可能进路。一条可能进路的始终端方向必须同时满足始端方向约束和终端方向约束，
那么这条可能进路才能成为进路。

对于第一个例子，就可以使用始端方向约束解决，对于可能的进路 $1 \rightarrow 3 \rightarrow 5$,
其方向是向右的。但始端信号机D1朝右，其防护的车辆必然向左行驶，则不满足始端方向约束，
因此$1 \rightarrow 3 \rightarrow 5$不是合法的进路。

\begin{table}[htpb!]
    \centering
    \caption{\label{route_end}终点和方向}
    \begin{threeparttable}
        \begin{tabular}{llccc}
            \toprule
            起点按钮       & 终点按钮       & 进路类型 & 终点        & 终端方向     \\
            \midrule
            通过           & 列车           & 通过     & 防护结点    & 终端信号朝向 \\
            通过           & 列车终端       & 通过     & LZA映射结点 & 始端信号朝向 \\
            列车(进站信号) & 列车(出站信号) & 接车     & 朝向结点    & 终端信号朝向 \\
            列车(出站信号) & 列车(进站信号) & 发车     & 防护结点    & 终端信号朝向 \\
            列车(出站信号) & 列车终端       & 发车     & LZA映射结点 & 始端信号朝向 \\
            调车           & 调车           & 调车     & 朝向结点    & 终端信号反向 \\
            \bottomrule
        \end{tabular}
    \end{threeparttable}
\end{table}

对于第二个例子，就需要用到终端方向约束来解决，在第二个例子中，起点按钮是列车按钮（进站信号），终点按钮是列车按钮（出站信号）
终点是朝向结点，到这里和上述推论一样没有问题。当终端按钮按下的是同向的出站信号机按钮，终端信号朝向就会和车辆行驶方向
相反，则违反了终端方向约束，不合法。
只有点击差置的反向出站信号机按钮，其信号机朝向才和行驶方向一致，成为合法进路。

\paragraph{}进路条件检查

进路条件即允许开放进路的站场状态。即对进路中的结点状态和途径的信号机的状态进行判断。对于信号机而言，应处于
防护状态，因为采用了图论算法，所以不需要像传统继电联锁逻辑一样验证敌对信号[]，对于结点而言，需要验证其必须
处于空闲状态，不得被封闭(锁闭)，不得被征用。这里将锁闭和征用区别开来。
封闭进路中的点称为锁闭，使用is\_lock表征，封闭进路链扩展集中的点成为征用，使用征用计数器used\_count来表征。
判断征用这里采用了和引用论文中不同的方法，这么做的好处是降低了算法时空复杂度。
每当一个结点被征用，则征用计数自增一，因为被征用的点不能成为进路中的点但可以成为
进路扩展集中的点，所以只要征用计数器大于零，则说明该结点被至少一条进路征用，不能建立包含该结点的进路。

\paragraph{}封闭区段

通过对进路的遍历，锁闭进路的点，重置点的曾占用flag
(曾占用flag是供进路解锁时三点检查法判断区段是否曾占用后又出清使用的，因此要在建立进路时重置)
并同时将进路的点的扩展集（即和该点有S关系的点集）中的点的征用计数器自增。

\paragraph{}点灯过程

点灯可以分情况讨论，当欲建立进路是发车进路时：
需要点亮发车信号机的允许信号（不考虑区间上的状态）。

当欲建立进路是接车进路时，
需要点亮进站（反向进站）信号机的相应允许信号，但和发车不同之处在于，进站信号机
所点亮之信号与接车的终点相关。因此本案采用特殊结点标记来判断接车进路会接车到哪种结点上。

通过进路和进站接车在点灯上的行为相似，通过进路和进站进路的点灯逻辑可以用表\ref{homw_light}来表示

\begin{table}[htpb!]
    \centering
    \caption{\label{homw_light}通过和进站信号}
    \begin{threeparttable}
        \begin{tabular}{ccc}
            \toprule
            起点 & 终点             & 进站信号机 \\
            \midrule
            咽喉 & 咽喉             & L          \\
            咽喉 & 站线             & UU         \\
            咽喉 & 18号道岔以上站线 & US         \\
            咽喉 & 正线             & U          \\
            \bottomrule
        \end{tabular}
    \end{threeparttable}
\end{table}

另外，得益于图论算法的强力驱动，本案还支持建立长调车进路，长调车进路开放信号时，需要开放途经
所有朝向和进路方向相背的调车信号机。由推论1，如果途经的某个结点有防护调车信号机，若进路车辆向左行驶
则该信号机位于结点的右端，若向右行驶，则信号机位于结点的左端。因此通过调车行驶方向，就可以取到所有
途经迎面的调车信号机。

\subsubsection{总取消进路}
因为uroj创建进路后只改变状态机中的状态，而不对创建的进路进行记录，因此当用户输入一个起点按钮
以取消进路时，需要先从实例中找到一条已经建立的进路。从用户所输入的信号机按钮可以得知：用户想
取消进路的方向，和用户欲取消进路的起点。这是因为对于起点来说，不论建立哪种进路，
起点总是始端信号机的防护结点，始端方向总是始端信号机的反向。因此有以下算法：

\begin{enumerate}[\indent i.]
    \item 初始化一个vector，压入起点
    \item 找到R有向图中从该vector顶部结点出发且符合指定进路方向的第一条边
    \item 如果该边的终点锁闭且空闲，则压入该终点至vector中，并跳转至2
    \item 若3的条件不满足，则返回vector
\end{enumerate}

我们称该vector为一可能的进路。该算法的作用仅是找到从给定起点向给定方向的最长连续锁闭结点。

那么，显然地，对于上述的可能进路。若点击终端或者中途的某个信号机，依然可以得出其一部分作为可能进路。
与创建进路类似，取消进路也要满足原子性，显然不能只取消进路的一部分。所以这种可能进路是不允许成为可取消的进路的。

uroj采用始端信号机状态约束来解决这一点，如果用户输入的信号机没有开放，
其必然不是某个现存进路的始端信号机。

但是对于长进路，途经的调车信号机必然是开放的，看起来没办法使用始端信号机状态来验证了。
但没关系，取消进路时会验证接近区段的状态，即接近区段必须空闲。这个约束是联锁逻辑所要求的。
在验证此逻辑同时验证接近区段必须未锁闭就能解决问题。因为如果一个区段锁闭则其一定存在于某个进路中。
从而一定不是某个进路的接近区段。

那么接近区段该如何得到呢？显然地，有了始端信号机，始端信号机的朝向节点其实就是进路的接近区段。

\subsubsection{总人解进路}
总人解是当车辆已经进入接近区段时采用的解锁方法，但实际上其适用性是包含了总取消的。因此其逻辑和
总取消大体上相同，只是在检查完解锁条件后需要延迟一定时间（本案采用3秒）再解锁。

\subsubsection{区故解进路}
在现实联锁中，区间故障解锁是需要登记并输入口令的，但作为一款仿真模拟应用，显然是不需要的。因此
其逻辑和总取消进路也差不多。不过需要表示层弹出对话框要求输入口令，
其中因为口令是预设的(123)，所以只需要在表现层判断即可，以优化后端的逻辑。

\subsubsection{调/列车辆}
车辆有自动创建和手动创建两种，在考试模式中，当用户创建的进路的起点同时是当前题目所要求进路的起点时，
在进路创建成功的同时会自动的在接近区段放置车辆。在练习模式中，车辆不会自动被放置。
用户需要手动选择结点以创建车辆。创建车辆分为两步

\paragraph{}生成车辆：车辆将会被生成在指定结点的一半处，具体过程是将生成点插入历经结点中，
并且令process = 0.5。

\paragraph{}启动自动行驶任务：每个车辆都会有一个tokio 任务，用于自动判断执行列车的行驶，
该任务会循环执行，首先先向左方自车辆所在的结点找到下一个进路结点（类似取消进路中所列的寻找进路的算法，不过在第三步直接返回），
如果找到的话则尝试移动车辆至该节点，如果没找到则向右方寻找。若左右两方都不能找到进路结点。则车保持不动。
若左右两方有一方是进路结点，则将尝试移动车辆至该结点，
尝试移动车辆的过程用语言叙述比较复杂，故此绘流程图 \ref{tmf},

图中，靶点即目标结点，今点即列车当前所处的结点。当process = 1时说明
列车已经行至今点的末尾，可以继续进行列车是否能够驶入靶点的判断。若
不足1，则说明尚未行驶到今点的尽头，应继续前进一个单位速度的距离。

确认靶点和今点的位置关系是为了判断物理上列车可以由今点驶入靶点。若根本不邻接
便不可能驶入靶点。

确认防护信号的状态是为了遵守列车行驶规则，即只有允许信号开放才能
驶过信号机。若信号不开放则也不能驶入。若该结点根本没有防护信号机
则说明列车可以直接驶入。

判断完成后，将列车驶入靶点，有如下几步：

\begin{enumerate}[\indent i.]
    \item 将靶点状态对象的状态置为 Occupied
    \item 将今点状态对象的状态置为 Vacant
    \item 将今点状态对象的曾占用标记置为 true
    \item 将靶点压入past\_node 中
    \item 将列车process置为0
\end{enumerate}

\begin{figure}[htbp!]
    \centering
    \input{figures/train_move_flow.tex}
    \caption{\label{tmf}移动车辆流程图}
\end{figure}

\subsubsection{状态共享}
状态共享指的是当多个用户访问一个实例时，他们都能实时的观察到该实例的所有状态。但是
逻辑上只能存在一个使用者，所以我们要对实例的操作权限做出一些限制。

对于存取某个实例的用户来说，可以分为三类身份：Guest、Player和Operator。
其中，对于所有的管理员用户都自动的拥有实例的Operator权限。而Player用户是每个实例唯一的，
也就是该实例的逻辑使用者，但为了管理员能对所有实例实时控制，因此管理员也拥有一个实例的
所有权限，即Operator是实例的事实使用者。

而对于Guest，所有使用 token 访问实例的非 Operator 用户都是Guest，Guest不能对instance做出
任何操作，而只能旁观。类似看直播一样的效果。设计Guest以及token的动机在于，一个实例的Player
或者 Operator 可以将实例的token分享给其他用户，如此一来拿到token的用户就可以通过token访问
到该实例，查看实例的实时状态。这种设计在演示教学上十分有用。比如教师可以使用本系统进行教学演示。
将 token 分享给其学生们，学生们可以藉此观看教师的演示，而无需投影或者直播演示。对于无论何种身份，
其区别只是Mutation的权限有区别，而订阅车站状态更新都是一样的。

得益于tokio提供的 broadcast channel，uroj可以将一个实例产生状态帧同时发送给不同的订阅者。
而这也正是状态共享能够得以实现的基础。

\subsection{性能优化}
业务层采用了许多技术以提升应用性能
\subsubsection{分布式SOA}
面向服务的体系结构（英语：service-oriented architecture）是一种分布式运算的软件设计方法。
软件的部分组件（调用者），可以透过网络上的通用协议调用另一个应用软件组件运行、运作，让调用者获得服务。
SOA原则上采用开放标准、与软件资源进行交互并采用表示的标准方式。一项服务应视为一个独立的功能单元，可以远程访问并独立运行与更新。
根据架构图，uroj可以无限制的增加api和runtime的服务器数量，从而组成集群。如此便可以根据实际负载而提高应用吞吐量和算力。
\subsubsection{优化查询}
某些GraphQL查询需要执行数百个数据库查询，这些查询通常包含重复的数据，可以通过DataLoader来修复之。
我们需要对查询分组，并且排除重复的查询。Dataloader就能完成这个工作，
facebook 给出了一个请求范围的批处理和缓存解决方案。
\begin{lstlisting}
pub struct UserLoader {
    pub pool: Arc<PgPool>,
}

#[async_trait::async_trait]
impl Loader<String> for UserLoader {
    type Value = User;
    type Error = Error;

    async fn load(&self, keys: &[String]) -> 
    Result<HashMap<String, Self::Value>, Self::Error> {
        let conn = self.pool.get().expect("...");
        let users = UserData::find_many(keys, &conn)
                  .expect("Can't get users' details");
        Ok(
          users.iter().map(|u|(u.id.clone(), u.into())).collect()
        )
    }
}
\end{lstlisting}

以本案中采用的 UserLoader 为例，每次在数据库中查询新User时，
都会将查询到的User放到Loader的缓存中（HashMap），若再查询相同的User，则会先在缓存中查找。若
缓存中没有则再去数据库中查询。

\subsubsection{异步}
大多数计算机程序的执行顺序与它的编写顺序相同。
第一行执行，然后是下一行，以此类推。
在同步编程中，当程序遇到一个不能立即完成的操作时，它将阻塞，直到该操作完成。
例如，建立一个TCP连接需要在网络上与一个peer进行交换，这可能需要相当长的时间。
在这段时间内，线程会被阻塞。

通过异步编程，不能立即完成的操作被暂停到后台。线程不会被阻塞，可以继续运行其他事情。
一旦操作完成，任务就会从其之前阻塞处恢复执行。

uroj 作为异步应用开发并采用 tokio crate 作为异步任务的运行时。
并且采用了rust性能最优的actix-web框架作为web服务器。