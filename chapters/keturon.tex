\begin{keturon}
    在本次设计中，因为工程量大，不可避免遇到了几个预料之外的问题。
    在多线程编程中，为了避免多个线程同时访问资源形成竞态条件，
    通常使用互斥锁（Mutex）来解决问题（本次设计使用的是异步编程，但是
    启用线程池的异步编程）。即当一个线程访问资源时为互斥锁上锁，如果
    互斥锁已经被锁则阻塞该线程，直至互斥锁被解锁，该线程再上锁继续程序。

    这种设计能保证同一时间某个资源至多只有一个线程对其存取，从而避免竞险。
    但是，本案不仅是多线程程序，还是异步程序。因此同步互斥锁是不能够使用
    的，在查询文档后，使用了tokio提供的异步锁。如果第二个线程尝试上异步锁
    则会被挂起。

    因为 Rust 所有权的设计和强制RAII的特性，当 MutexGuard（即被互斥锁保护的资源
    在上锁后得到的句柄）离开作用域后，其drop函数会被调用，互斥锁会被自动解锁。
    所以在在函数调用栈很长的时候会不经意间为同一个资源上两次锁，这样会导致死锁
    的发生。当调试时发现最初的代码有不少死锁的问题。
    在任何编程语言中，避免死锁都是十分需要注意的。

    展望：

    \paragraph{} 当前使用JSON对于用户仍然具有一定的学习成本，
    如果能支持对于车站描述文件的图形化编辑，并且提供实时的车站布局画面预览
    ，将进一步提升用户体验。
    
    另外，在用户提交车站描述文件后，应当对车站描述文件
    做一次有效性验证，以避免用户输入的信息导致运行时崩溃或生成的实例不可用。
    车站有效性验证应包含如下几项内容：
    \begin{enumerate}[\indent i.]
        \item 无垂悬引用 （严格）
        \item 判断$R$图没有孤立点（不严格）
        \item $R$，$S$关系的对称性验证，（$S$严格，$R$不严格）
        \item 验证道岔区段组第一性质定理（严格）
        \item 验证每个结点的度（严格）
    \end{enumerate}
    只有严格项目满足，用户输入的车站描述文件才能视之为合法的车站。可以满足
    实例所需要的种种拓扑关系。而不严格项目说明不会产生致命的错误，但显然不是
    现实中合理的车站。因此对用户输入中违反严格项时返回错误，违反非严格项
    时返回警告。

    因为时间关系，本案未能依上述设计对用户的输入进行初步检查。


    \paragraph{} 目前为实现热插拔，没有在运行时使用网关，在表现层通过实例配置时指定的
    运行时创建对应运行时服务的Apollo客户端，从而实现在指定的运行时上运行实例。
    本案的原初设计是在api服务中集成实例调度器（Instance Scheduler），
    其具体职能是管理调度安排实例
    运行在哪个运行时上，还可以将多个运行时视为一种计算“资源”，
    将多个运行时服务池化称为运行时池，通过池中各个运行时的
    负载（运行实例数量、CPU负责、网络IO）等参数来决策新开始的实例应该由哪个运行时
    来运行。调度器通过tarpc（Google 开发的一个Rust专用的rpc专案）和各个运行时连接
    各个运行时作为tarpc服务器，调度器作为tarpc客户端。调度器在某个实例开始时间到时
    通过tarpc服务将新建实例配置传送给一个运行时以运行。
    但是十分遗憾的是，在开发完成调试程序时，发现tarpc要求异步库tokio的最低版本是1.0，
    而本案使用的web 异步框架
    actix-web（latest release）使用tokio版本是0.3，因为异步运行时的版本不兼容，
    导致tarpc与actix-web不能集成于一个项目中。当时我寻求actix-web的替代品，但是
    本案的设计宗旨就是高性能，因为垂涎于actix-web的效率，实在不忍心将actix-web替换为
    别的web框架。因此便舍去了调度器方案。

    在此之后，我又尝试使用redis或者etcd等方案来实现，奈何时间过于紧迫，没添加一项新
    流程、新技术，都意味着阅读学习其使用文档说明、配置环境、处理和现有架构的耦合等等问题，
    要花费的时间不可估算（字面上的意思）。因此最终还是舍弃了使用redis或etcd的方案。
    随着actix-web的更新（actix-web的4.0.x beta版已经使用tokio 1.0了）再将调度器加入api服务中
    就可以了。

\end{keturon}